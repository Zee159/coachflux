# Safety Check System

## ✅ Zero Unsafe Code Enforcement

CoachFlux has a comprehensive safety check system that enforces **zero tolerance** for unsafe TypeScript patterns.

---

## 🔒 What's Checked

### 1. TypeScript Strict Mode
All strict type-checking options enabled:
- ✅ `strict: true`
- ✅ `noImplicitAny`
- ✅ `strictNullChecks`
- ✅ `noUncheckedIndexedAccess`
- ✅ `noImplicitReturns`
- ✅ `noUnusedLocals`
- ✅ `noUnusedParameters`

### 2. ESLint Strict Rules
- ✅ No `@typescript-eslint/no-explicit-any`
- ✅ No unsafe assignments/calls/returns
- ✅ No floating promises
- ✅ Strict boolean expressions
- ✅ Max warnings: **0**

### 3. Custom Safety Scan
Scans for:
- ❌ `any` type annotations
- ❌ `as any` type assertions  
- ❌ `as unknown as` double assertions
- ❌ `@ts-ignore` directives
- ❌ `@ts-expect-error` directives
- ❌ `@ts-nocheck` directives
- ❌ `eslint-disable` directives

---

## 🎯 Proper Types Instead of `any`

### Framework Types (`convex/types.ts`)

**OrgValue**
```typescript
interface OrgValue {
  key: string;
  description: string;
}
```

**FrameworkStep**
```typescript
interface FrameworkStep {
  name: string;
  system_objective: string;
  required_fields_schema: Record<string, unknown>;
}
```

**Framework**
```typescript
interface Framework {
  id: string;
  steps: FrameworkStep[];
}
```

**ValidationResult**
```typescript
interface ValidationResult {
  verdict: "pass" | "fail";
  reasons: string[];
}
```

**ReflectionPayload**
```typescript
interface ReflectionPayload {
  [key: string]: unknown;
}
```

---

## 🛡️ Safe Error Handling

### Before (Unsafe)
```typescript
} catch (error: any) {
  alert(error.message);
}
```

### After (Safe)
```typescript
} catch (error: unknown) {
  const message = error instanceof Error ? error.message : "Something went wrong";
  alert(message);
}
```

**Why?** 
- `error: unknown` is the recommended TypeScript pattern
- Type guard (`instanceof Error`) ensures safe property access
- No assumptions about error structure

---

## 📋 Running Safety Checks

### Individual Checks

```bash
# TypeScript type checking
pnpm type-check

# ESLint
pnpm lint

# Custom safety scan
pnpm safety-scan
```

### Combined Safety Check
```bash
# Runs all three checks
pnpm safety
```

### Before Build
```bash
# Build automatically runs safety check first
pnpm build
```

---

## 🚨 Safety Check Failures

### If Safety Check Fails

The build will **fail** if any of these are detected:
- TypeScript errors
- ESLint warnings/errors  
- Unsafe code patterns

**Fix immediately** - do not disable checks or use workarounds!

---

## 📝 Safety Scan Details

### What Gets Scanned
- All `.ts` and `.tsx` files
- In `src/` and `convex/` directories
- Excluding:
  - `node_modules`
  - `dist`, `build`
  - `_generated` (auto-generated by Convex)
  - Config files (`.eslintrc.cjs`, `vite.config.ts`)

### Example Output

**Pass:**
```
🔍 Scanning for unsafe code patterns...

✅ No unsafe patterns found! Your code is clean.
```

**Fail:**
```
🔍 Scanning for unsafe code patterns...

❌ Found 3 unsafe pattern(s):

1. Type annotation "any"
   File: convex/coach.ts:137
   Code: const values = (org.values ?? []).map((v: any) => v.key);

2. Type assertion "as any"
   File: src/Dashboard.tsx:45
   Code: const data = response as any;

3. @ts-ignore directive
   File: src/SessionView.tsx:102
   Code: // @ts-ignore

❌ Safety check failed: 3 unsafe pattern(s) detected.
```

---

## 🏗️ Architecture

### Type Safety Layers

**Layer 1: TypeScript Compiler**
- Static type checking at compile time
- Catches type mismatches, undefined access
- Enforces strict mode rules

**Layer 2: ESLint**
- Linting rules for TypeScript patterns
- Catches unsafe practices missed by compiler
- Enforces code quality standards

**Layer 3: Custom Safety Scan**
- Regex-based pattern detection
- Catches workarounds and escape hatches
- Zero tolerance enforcement

---

## 🎓 Why This Matters

### Production Safety
- **No runtime type errors** from `any` types
- **No silent failures** from ignored type errors
- **Predictable behavior** with proper types

### Code Quality
- **Self-documenting** through explicit types
- **Better refactoring** with type safety
- **Fewer bugs** caught at compile time

### Team Confidence
- **Trust the types** - they're always accurate
- **Safe to refactor** - compiler catches breaks
- **Clear contracts** between modules

---

## 💡 Best Practices

### 1. Always Define Proper Types
```typescript
// ❌ Bad
function process(data: any) {
  return data.items.map((item: any) => item.name);
}

// ✅ Good
interface Item {
  name: string;
  id: string;
}

interface Data {
  items: Item[];
}

function process(data: Data): string[] {
  return data.items.map((item) => item.name);
}
```

### 2. Use Type Guards for Unknown Types
```typescript
// ❌ Bad
const value = JSON.parse(str) as MyType;

// ✅ Good
function isMyType(value: unknown): value is MyType {
  return typeof value === 'object' && value !== null && 'requiredProp' in value;
}

const parsed = JSON.parse(str);
if (isMyType(parsed)) {
  // Safe to use as MyType
}
```

### 3. Handle Errors Properly
```typescript
// ❌ Bad
} catch (e) {
  console.log(e.message);  // Error: e is unknown
}

// ✅ Good  
} catch (error: unknown) {
  if (error instanceof Error) {
    console.log(error.message);
  } else {
    console.log(String(error));
  }
}
```

### 4. Use Proper Index Access
```typescript
// ❌ Bad
const value = process.env.API_KEY;  // Error with strict mode

// ✅ Good
const value = process.env["API_KEY"];  // Explicitly handles undefined
```

---

## 🔧 Configuration

### TypeScript (`tsconfig.json`)
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true
  }
}
```

### ESLint (`.eslintrc.cjs`)
```javascript
{
  rules: {
    '@typescript-eslint/no-explicit-any': 'error',
    '@typescript-eslint/no-unsafe-assignment': 'error',
    '@typescript-eslint/no-unsafe-member-access': 'error',
    '@typescript-eslint/no-unsafe-call': 'error',
    '@typescript-eslint/no-unsafe-return': 'error',
    '@typescript-eslint/no-floating-promises': 'error',
    '@typescript-eslint/strict-boolean-expressions': 'error'
  }
}
```

### Safety Scan (`scripts/safety-check.js`)
```javascript
const UNSAFE_PATTERNS = [
  { pattern: /:\s*any\b/g, name: 'Type annotation "any"' },
  { pattern: /\bas\s+any\b/g, name: 'Type assertion "as any"' },
  { pattern: /\bas\s+unknown\s+as\b/g, name: 'Double assertion "as unknown as"' },
  { pattern: /@ts-ignore/g, name: '@ts-ignore directive' },
  { pattern: /@ts-expect-error/g, name: '@ts-expect-error directive' },
  { pattern: /@ts-nocheck/g, name: '@ts-nocheck directive' },
  { pattern: /eslint-disable/g, name: 'eslint-disable directive' },
];
```

---

## ✅ Current Status

### Safety Check: **PASSING** ✅

```
✅ TypeScript: 0 errors
✅ ESLint: 0 warnings  
✅ Safety Scan: 0 unsafe patterns

All code is type-safe and follows strict safety guidelines!
```

---

## 📚 Resources

- [TypeScript Strict Mode](https://www.typescriptlang.org/tsconfig#strict)
- [ESLint TypeScript Rules](https://typescript-eslint.io/rules/)
- [Effective TypeScript](https://effectivetypescript.com/)
- [Type Safety Best Practices](https://github.com/typescript-cheatsheets/react#section-1-setup-typescript-with-react)

---

**Your CoachFlux MVP is built with production-grade type safety! 🛡️**
